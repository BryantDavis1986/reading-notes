# Read: Class 33 - OAUTH
* As for the actual OAuth 2 flow, it looks as follows:
* The Consumer makes a request to the Service Provider authorization endpoint to authorize the user.
+ The Service Provider authenticates the user and prompts them whether to authorize the Consumer to access their information.
+ If the user authorizes the Consumer, the Service Provider redirects back to the redirect URI on the Consumer’s website with a temporary access code.
+ The Consumer calls the token endpoint on the Service Provider website to exchange the code for a more permanent access token.
+ The Service Provider grants an access token which can be used to authenticate subsequent requests to protected resources
* The Client ID and secret are obtained when registering your application on the Service Provider’s website. Some Service Providers may call them something else, like Facebook, for example, will refer to them as the App ID and App Secret. The Authorization and Token endpoints can typically be obtained from the developer documentation of the Service Provider.
* The redirect URI is something which you can specify when configuring the OAuth authentication on the Consumer. This needs to match up with whatever you specify when creating the application on the Service Provider. This will normally be referred to as either a redirect URL or callback URL or some sort of variation of that.
* You will need to register the Cookie and OAuth authentication services and also add the authentication middleware. First off, update the ConfigureServices method of your Startup class to register the required authentication services:
* The call to AddAuthentication registers the authentication services. It specified the DefaultAuthenticateScheme and the DefaultSignInScheme as the cookies, and the DefaultChallengeScheme as GitHub. What this means is that when ASP.NET check to see whether a user is authenticated, it will use the cookie authentication handler.
* When we call ChallengeAsync() to log a user in, the GitHub authentication scheme (in other words the OAuth authentication handler) will be challenged. Finally, once the user is authenticated, their authentication information will be saved in a cookie, since that is the DefaultSignInScheme.
* Then we register the OAuth authentication handler by calling the AddOAuth() method and setting the authenticationScheme parameter as GitHub (the same we specified for the DefaultChallengeScheme earlier).
* For the OAuth authentication handler, you need to specify the ClientId, ClientSecret and CallbackPath. The CallbackPath is the path where the identity provider will call back to after the user has authenticated (i.e. the callback URL we specified when we registered our application in GitHub).
* We also specify the AuthorizationEndpoint, TokenEndpoint and UserInformationEndpoint. The latter is not called by the OAuth authentication handler itself, but instead is something we need to call to obtain more information about the user (name, email address etc.)
* You will have noticed that the OAuth authentication configuration referenced the GitHub:ClientId and GitHub:ClientSecret configuration settings. You will need to update your appsettings.json file to add these settings. Specify the values for your own GitHub application which you registered earlier
* We need a way to challenge the authentication handler. For this I will create a normal MVC Controller called AccountController and specify a Login action which will return a ChallengeResult and therefore challenge the OAuth authentication handler (because we specified GitHub as the DefaultChallengeScheme):
* Next, we can add a big button on the Home page which allows the user to log in with their GitHub credentials. This button will simply call the Login action on the Controller class. Update the HTML for your /Pages/Index.cshtml file as follows:
* Note that we retrieve the claims stored for the user, and store the values for those claims in properties on our IndexModel class. This will allow use to use these values from the Razor page.
* Let’s say that we want to display the list of repositories for the user on the page as well. To do this, we need to call the /user/repos endpoint of the GitHub API, passing along the access_token which we received from GitHub.
* We will need to save the tokens received from GitHub. We can do that by setting the SaveTokens property when we configure the OAuth authentication handler: