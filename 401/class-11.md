# Readings: EF Core & APIs
## Entity Framework Core
* Entity Framework (EF) Core is a lightweight, extensible, open source and cross-platform version of the popular Entity Framework data access technology.
* EF Core can serve as an object-relational mapper (O/RM), enabling .NET developers to work with a database using .NET objects, and eliminating the need for most of the data-access code they usually need to write.
* With EF Core, data access is performed using a model. A model is made up of entity classes and a context object that represents a session with the database, allowing you to query and save data. See Creating a Model to learn more.
* You can generate a model from an existing database, hand code a model to match your database, or use EF Migrations to create a database from your model, and then evolve it as your model changes over time.
## Data Seeding
* Data seeding is the process of populating a database with an initial set of data
* There are several ways this can be accomplished in EF Core:
* Model seed data
* Manual migration customization
* Custom initialization logic
* Unlike in EF6, in EF Core, seeding data can be associated with an entity type as part of the model configuration. Then EF Core migrations can automatically compute what insert, update or delete operations need to be applied when upgrading the database to a new version of the model.
* This type of seed data is managed by migrations and the script to update the data that's already in the database needs to be generated without connecting to the database. This imposes some restrictions:
* The primary key value needs to be specified even if it's usually generated by the database. It will be used to detect data changes between migrations.
* Previously seeded data will be removed if the primary key is changed in any way.
* If your scenario includes any of the following it is recommended to use custom initialization logic described in the last section:
* Temporary data for testing
* Data that depends on database state
* Data that needs key values to be generated by the database, including entities that use alternate keys as the identity
* Data that requires custom transformation (that is not handled by value conversions), such as some password hashing
* Data that requires calls to external API, such as ASP.NET Core Identity roles and users creation
## Entity Framework Core
* The Contoso University sample web app demonstrates how to create an ASP.NET Core Razor Pages app using Entity Framework (EF) Core.
* Asynchronous programming is the default mode for ASP.NET Core and EF Core.
* A web server has a limited number of threads available, and in high load situations all of the available threads might be in use. When that happens, the server can't process new requests until the threads are freed up. With synchronous code, many threads may be tied up while they aren't actually doing any work because they're waiting for I/O to complete. With asynchronous code, when a process is waiting for I/O to complete, its thread is freed up for the server to use for processing other requests. As a result, asynchronous code enables server resources to be used more efficiently, and the server is enabled to handle more traffic without delays
* Asynchronous code does introduce a small amount of overhead at run time. For low traffic situations, the performance hit is negligible, while for high traffic situations, the potential performance improvement is substantial.
* Some things to be aware of when writing asynchronous code that uses EF Core:
* Only statements that cause queries or commands to be sent to the DB are executed asynchronously. That includes, ToListAsync, SingleOrDefaultAsync, FirstOrDefaultAsync, and SaveChangesAsync. It doesn't include statements that just change an IQueryable, such as var students = context.Students.Where(s => s.LastName == "Davolio").
* An EF Core context isn't thread safe: don't try to do multiple operations in parallel.
* To take advantage of the performance benefits of async code, verify that library packages (such as for paging) use async if they call EF Core methods that send queries to the DB.